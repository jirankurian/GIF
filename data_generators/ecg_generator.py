"""
ECG Generator - Complete Clinical Data Pipeline
==============================================

High-fidelity synthetic ECG signal generator combining biophysical modeling with
clinical realism. This module implements both the foundational McSharry et al. (2003)
dynamical systems model for clean ECG generation and a comprehensive clinical noise
layer that simulates real-world recording conditions.

The complete pipeline consists of three main components:

**Core Biophysical Engine (Task 1.3):**
1. ECGPhysicsEngine: McSharry ODE-based cardiac electrophysiology simulation

**Clinical Realism Layer (Task 1.4):**
2. ClinicalNoiseModel: Realistic noise sources found in clinical ECG recordings
3. RealisticECGGenerator: Complete orchestrator combining clean signals with clinical noise

Mathematical Foundation:
The biophysical model uses three coupled ODEs to simulate cardiac electrical activity:

    dx/dt = y
    dy/dt = z
    dz/dt = αz - ω²y - force(t)

Where x represents the ECG signal, and force(t) generates PQRST waves through
Gaussian functions positioned at specific cardiac cycle phases.

Clinical Noise Sources:
- Baseline Wander: Low-frequency respiratory artifacts (0.15-0.3 Hz)
- Muscle Artifact: High-frequency EMG interference from patient movement
- Powerline Interference: 50/60 Hz electrical grid contamination

Key Features:
- Physics-based cardiac electrophysiology simulation
- Realistic clinical noise modeling from literature
- Configurable heart rate (30-200 BPM) and noise levels
- Clean and realistic ECG signal generation
- Ground truth tracking for supervised learning
- Structured polars DataFrame output with metadata

Usage Example:
    >>> # Generate realistic clinical ECG data
    >>> generator = RealisticECGGenerator()
    >>> noise_levels = {'baseline': 0.1, 'muscle': 0.02, 'powerline': 0.01}
    >>> ecg_data = generator.generate(
    ...     duration_seconds=10.0, sampling_rate=500,
    ...     heart_rate_bpm=75.0, noise_levels=noise_levels
    ... )
    >>> print(f"Generated realistic ECG with clinical noise")

    >>> # Or generate clean signals for comparison
    >>> engine = ECGPhysicsEngine(heart_rate_bpm=75.0)
    >>> clean_ecg = engine.generate_ecg_segment(duration_seconds=10.0, sampling_rate=500)

References:
    McSharry, P. E., Clifford, G. D., Tarassenko, L., & Smith, L. A. (2003).
    A dynamical model for generating synthetic electrocardiogram signals.
    IEEE Transactions on Biomedical Engineering, 50(3), 289-294.

Author: GIF Development Team
Phase: 1.3 - Core Biophysical Engine, 1.4 - Clinical Realism Layer
"""

import numpy as np
import polars as pl
from typing import List, Tuple, Dict, Optional
from scipy.integrate import solve_ivp
from scipy import signal


class ECGPhysicsEngine:
    """
    Core biophysical engine for generating clean ECG signals using dynamical systems.

    This class implements the McSharry et al. (2003) model, which uses a system of
    three coupled ordinary differential equations to simulate the heart's electrical
    conduction cycle. The model generates realistic ECG morphology including the
    characteristic P, Q, R, S, and T waves through physics-based simulation.

    The heart's electrical activity is modeled as a trajectory in 3D state space,
    where the system evolves according to biophysically-motivated dynamics. Each
    heartbeat corresponds to one complete orbit around a limit cycle, with the
    characteristic ECG waves generated by Gaussian force functions that represent
    different phases of cardiac electrical conduction.

    Key Features:
    - Biophysically accurate cardiac electrophysiology model
    - Configurable heart rate with automatic frequency scaling
    - Standard PQRST wave parameters from literature
    - Efficient numerical integration using scipy
    - Clean, noise-free output suitable for baseline studies

    Attributes:
        heart_rate_bpm (float): Target heart rate in beats per minute
        omega (float): Angular frequency (rad/s) corresponding to heart rate
        alpha (float): Damping parameter for system stability
        pqrst_params (dict): Parameters for P, Q, R, S, T wave Gaussians

    Example:
        >>> engine = ECGPhysicsEngine(heart_rate_bpm=60.0)
        >>> ecg = engine.generate_ecg_segment(duration_seconds=5.0, sampling_rate=500)
        >>> print(f"Generated {len(ecg)} samples at 60 BPM")
    """

    def __init__(self, heart_rate_bpm: float = 60.0):
        """
        Initialize the ECG physics engine with specified heart rate.

        Args:
            heart_rate_bpm (float): Target heart rate in beats per minute.
                Must be in the physiologically reasonable range of 30-200 BPM.
                Default 60 BPM represents a normal resting heart rate.

        Raises:
            ValueError: If heart rate is outside the valid physiological range.

        Example:
            >>> engine = ECGPhysicsEngine(heart_rate_bpm=75.0)
            >>> print(f"Configured for {engine.heart_rate_bpm} BPM")
        """
        # Validate heart rate
        if not (30.0 <= heart_rate_bpm <= 200.0):
            raise ValueError(
                f"Heart rate {heart_rate_bpm} BPM is outside physiological range (30-200 BPM)"
            )

        self.heart_rate_bpm = heart_rate_bpm

        # Calculate angular frequency: ω = 2π × (beats/min) / (60 s/min)
        self.omega = 2.0 * np.pi * heart_rate_bpm / 60.0

        # Damping parameter for system stability (from McSharry et al.)
        self.alpha = 1.0

        # PQRST wave parameters from McSharry et al. (2003)
        # Each tuple contains (theta_i, a_i, b_i) where:
        # - theta_i: angular position of wave peak (radians)
        # - a_i: amplitude scaling factor
        # - b_i: width parameter (standard deviation)
        self.pqrst_params = {
            'P': (-np.pi/3, 1.2, 0.25),    # P wave: atrial depolarization
            'Q': (-np.pi/12, -5.0, 0.1),   # Q wave: early ventricular depolarization
            'R': (0.0, 30.0, 0.1),         # R wave: main ventricular depolarization
            'S': (np.pi/12, -7.5, 0.1),    # S wave: late ventricular depolarization
            'T': (np.pi/2, 0.75, 0.4),     # T wave: ventricular repolarization
        }

    def _ecg_model_odes(self, t: float, state: List[float]) -> List[float]:
        """
        Define the McSharry dynamical system for ECG generation.

        This method implements the three coupled ordinary differential equations
        that govern the heart's electrical activity in the McSharry model. The
        system evolves on a limit cycle in 3D state space, with the x-component
        representing the final ECG signal.

        The governing equations are:
            dx/dt = y
            dy/dt = z
            dz/dt = αz - ω²y - force(t)

        Where force(t) is the sum of Gaussian functions representing the P, Q, R, S,
        and T waves of the cardiac cycle. Each Gaussian is positioned at a specific
        angular location and has characteristic amplitude and width.

        Args:
            t (float): Current time (not directly used, but required by solve_ivp).
            state (List[float]): Current state [x, y, z] of the dynamical system.

        Returns:
            List[float]: Time derivatives [dx/dt, dy/dt, dz/dt] at current state.

        Mathematical Details:
            The force term is computed as:
            force = Σ a_i * exp(-(θ - θ_i)² / (2 * b_i²))

            Where θ = arctan2(y, x) is the current angular position on the limit cycle,
            and (θ_i, a_i, b_i) are the parameters for each PQRST wave component.
        """
        x, y, z = state

        # Calculate current angular position on the limit cycle
        # This determines which phase of the cardiac cycle we're in
        theta = np.arctan2(y, x)

        # Compute the force term as sum of Gaussian functions for PQRST waves
        force = 0.0
        for wave_name, (theta_i, a_i, b_i) in self.pqrst_params.items():
            # Each Gaussian represents one component of the ECG waveform
            # The angular difference determines the timing of each wave
            angular_diff = theta - theta_i

            # Handle angular wraparound (ensure difference is in [-π, π])
            while angular_diff > np.pi:
                angular_diff -= 2 * np.pi
            while angular_diff < -np.pi:
                angular_diff += 2 * np.pi

            # Gaussian force function for this wave component
            gaussian_force = a_i * np.exp(-(angular_diff**2) / (2 * b_i**2))
            force += gaussian_force

        # McSharry dynamical system equations
        dx_dt = y
        dy_dt = z
        dz_dt = self.alpha * z - (self.omega**2) * y - force

        return [dx_dt, dy_dt, dz_dt]

    def generate_ecg_segment(
        self,
        duration_seconds: float,
        sampling_rate: int = 500
    ) -> pl.DataFrame:
        """
        Generate a clean ECG signal segment using the biophysical model.

        This method integrates the McSharry dynamical system over the specified
        time duration to produce a mathematically clean ECG signal. The resulting
        signal contains the characteristic PQRST waves with proper timing and
        morphology for the configured heart rate.

        The integration starts from an initial state on the unit circle and
        evolves according to the coupled ODEs. The x-component of the solution
        represents the final ECG voltage signal.

        Args:
            duration_seconds (float): Length of ECG segment to generate in seconds.
                Must be positive. Typical values: 5-60 seconds.
            sampling_rate (int): Number of samples per second (Hz).
                Must be positive. Typical values: 250-1000 Hz for clinical ECG.
                Default 500 Hz provides good temporal resolution.

        Returns:
            pl.DataFrame: ECG signal data with columns:
                - 'time': Time values in seconds (float64)
                - 'voltage': ECG voltage in arbitrary units (float64)

        Raises:
            ValueError: If duration or sampling rate are invalid.
            RuntimeError: If ODE integration fails.

        Example:
            >>> engine = ECGPhysicsEngine(heart_rate_bpm=72.0)
            >>> ecg = engine.generate_ecg_segment(duration_seconds=10.0, sampling_rate=500)
            >>> print(f"Generated {len(ecg)} samples over {10.0} seconds")
            >>> print(f"Voltage range: {ecg['voltage'].min():.3f} to {ecg['voltage'].max():.3f}")
        """
        # Validate inputs
        if duration_seconds <= 0:
            raise ValueError(f"Duration must be positive, got {duration_seconds}")

        if sampling_rate <= 0:
            raise ValueError(f"Sampling rate must be positive, got {sampling_rate}")

        if sampling_rate < 100:
            raise ValueError(f"Sampling rate {sampling_rate} Hz is too low for ECG (minimum 100 Hz)")

        if duration_seconds > 300:  # 5 minutes seems reasonable upper limit
            raise ValueError(f"Duration {duration_seconds} seconds is too long (maximum 300 s)")

        try:
            # Create time array for the ECG segment
            n_samples = int(duration_seconds * sampling_rate)
            time_array = np.linspace(0, duration_seconds, n_samples)

            # Initial state: start on the unit circle at (1, 0, 0)
            # This corresponds to the beginning of a cardiac cycle
            initial_state = [1.0, 0.0, 0.0]

            # Solve the ODE system using scipy's adaptive integrator
            # RK45 (Runge-Kutta) method provides good accuracy and stability
            solution = solve_ivp(
                fun=self._ecg_model_odes,
                t_span=(0, duration_seconds),
                y0=initial_state,
                t_eval=time_array,
                method='RK45',
                rtol=1e-8,  # Relative tolerance for accuracy
                atol=1e-10  # Absolute tolerance for accuracy
            )

            # Check if integration was successful
            if not solution.success:
                raise RuntimeError(f"ODE integration failed: {solution.message}")

            # Extract the ECG signal (x-component of the solution)
            ecg_voltage = solution.y[0]  # x(t) represents the ECG signal

            # Create structured output DataFrame
            ecg_df = pl.DataFrame({
                "time": time_array,
                "voltage": ecg_voltage
            })

            return ecg_df

        except Exception as e:
            if isinstance(e, (ValueError, RuntimeError)):
                raise  # Re-raise our custom exceptions
            else:
                raise RuntimeError(f"ECG generation failed: {str(e)}") from e


class ClinicalNoiseModel:
    """
    Generator for realistic clinical noise sources found in ECG recordings.

    This class models the common artifacts and noise sources that contaminate
    real-world ECG signals in clinical settings. These noise sources are critical
    for training robust medical AI systems that must perform reliably in the
    presence of realistic recording conditions.

    The model implements three primary noise sources based on clinical literature:
    1. Baseline Wander: Low-frequency drift caused by patient respiration
    2. Muscle Artifact: High-frequency EMG interference from patient movement
    3. Powerline Interference: 50/60 Hz contamination from electrical grid

    Each noise source is modeled using established signal processing techniques
    that capture the essential characteristics observed in real clinical data.
    The composite noise can be scaled and combined to simulate different
    recording environments and patient conditions.

    Key Features:
    - Physiologically realistic noise characteristics
    - Configurable amplitude levels for different clinical scenarios
    - Proper frequency content matching clinical observations
    - Efficient generation using scipy signal processing

    Example:
        >>> noise_model = ClinicalNoiseModel(seed=42)
        >>> time = np.linspace(0, 10, 5000)
        >>> noise_levels = {'baseline': 0.1, 'muscle': 0.02, 'powerline': 0.01}
        >>> noise = noise_model.generate_composite_noise(time, 500, noise_levels)
        >>> print(f"Generated clinical noise with RMS: {np.std(noise):.4f}")
    """

    def __init__(self, seed: Optional[int] = None):
        """
        Initialize the clinical noise model.

        Args:
            seed (int, optional): Random seed for reproducible noise generation.
                If None, uses system entropy for random initialization.
        """
        self.rng = np.random.default_rng(seed)

    def _generate_baseline_wander(self, time_array: np.ndarray, amplitude: float = 0.1) -> np.ndarray:
        """
        Generate baseline wander caused by patient respiration.

        Baseline wander is a low-frequency artifact that causes the ECG baseline
        to drift up and down. It's primarily caused by changes in electrode-skin
        impedance during respiration and patient movement. This artifact typically
        has frequencies between 0.15-0.3 Hz corresponding to normal respiratory rates.

        Args:
            time_array (np.ndarray): Time values at which to generate the wander.
            amplitude (float): Peak amplitude of the baseline wander in mV.
                Typical clinical values: 0.05-0.15 mV.

        Returns:
            np.ndarray: Baseline wander signal with same length as time_array.

        Technical Implementation:
            Uses a low-frequency sine wave with random phase and slight frequency
            variation to model the quasi-periodic nature of respiratory artifacts.
        """
        # Respiratory frequency range: 12-18 breaths/min = 0.2-0.3 Hz
        base_frequency = self.rng.uniform(0.15, 0.3)

        # Add slight frequency modulation for realism
        freq_variation = 0.02 * np.sin(2 * np.pi * 0.05 * time_array)
        instantaneous_freq = base_frequency + freq_variation

        # Random phase offset
        phase = self.rng.uniform(0, 2 * np.pi)

        # Generate baseline wander
        baseline_wander = amplitude * np.sin(2 * np.pi * instantaneous_freq * time_array + phase)

        return baseline_wander

    def _generate_muscle_artifact(self, time_array: np.ndarray, amplitude: float = 0.02) -> np.ndarray:
        """
        Generate muscle artifact (EMG interference) from patient movement.

        Muscle artifact appears as high-frequency noise caused by electrical
        activity from skeletal muscles. This interference is most prominent
        when patients move, shiver, or have muscle tension. The artifact
        typically contains frequencies above 20 Hz and can significantly
        obscure the ECG signal.

        Args:
            time_array (np.ndarray): Time values at which to generate the artifact.
            amplitude (float): RMS amplitude of the muscle artifact in mV.
                Typical clinical values: 0.01-0.05 mV depending on patient movement.

        Returns:
            np.ndarray: Muscle artifact signal with same length as time_array.

        Technical Implementation:
            Generates white noise and applies a high-pass Butterworth filter
            to retain only the high-frequency components characteristic of EMG.
        """
        # Generate white noise
        white_noise = self.rng.normal(0, 1, len(time_array))

        # Calculate sampling rate from time array
        if len(time_array) > 1:
            dt = time_array[1] - time_array[0]
            sampling_rate = 1.0 / dt
        else:
            sampling_rate = 500.0  # Default fallback

        # Design high-pass Butterworth filter for EMG characteristics
        # Cutoff at 20 Hz to simulate muscle electrical activity
        cutoff_freq = 20.0  # Hz
        nyquist_freq = sampling_rate / 2.0

        if cutoff_freq < nyquist_freq:
            # Normalized cutoff frequency
            normalized_cutoff = cutoff_freq / nyquist_freq

            # Design 4th order Butterworth high-pass filter
            b, a = signal.butter(4, normalized_cutoff, btype='high')

            # Apply filter to white noise
            filtered_noise = signal.filtfilt(b, a, white_noise)
        else:
            # If cutoff frequency is too high, just use white noise
            filtered_noise = white_noise

        # Scale to desired amplitude (RMS)
        current_rms = np.std(filtered_noise)
        if current_rms > 0:
            muscle_artifact = filtered_noise * (amplitude / current_rms)
        else:
            muscle_artifact = np.zeros_like(time_array)

        return muscle_artifact

    def _generate_powerline_interference(
        self,
        time_array: np.ndarray,
        sampling_rate: int,
        amplitude: float = 0.01,
        frequency: float = 50.0
    ) -> np.ndarray:
        """
        Generate powerline interference from electrical grid contamination.

        Powerline interference appears as a constant sinusoidal signal at the
        electrical grid frequency (50 Hz in Europe, 60 Hz in North America).
        This artifact is caused by electromagnetic coupling between the ECG
        recording equipment and nearby electrical devices or power lines.

        Args:
            time_array (np.ndarray): Time values at which to generate interference.
            sampling_rate (int): Sampling rate in Hz for proper frequency calculation.
            amplitude (float): Peak amplitude of the powerline interference in mV.
                Typical clinical values: 0.01-0.03 mV.
            frequency (float): Powerline frequency in Hz. Default 50 Hz (European).
                Use 60 Hz for North American settings.

        Returns:
            np.ndarray: Powerline interference signal with same length as time_array.

        Technical Implementation:
            Generates a pure sinusoidal signal at the specified powerline frequency
            with random phase offset to simulate different recording conditions.
        """
        # Validate frequency against Nyquist limit
        nyquist_freq = sampling_rate / 2.0
        if frequency >= nyquist_freq:
            raise ValueError(
                f"Powerline frequency {frequency} Hz exceeds Nyquist limit {nyquist_freq} Hz"
            )

        # Random phase offset for realism
        phase = self.rng.uniform(0, 2 * np.pi)

        # Generate pure sinusoidal interference
        powerline_interference = amplitude * np.sin(2 * np.pi * frequency * time_array + phase)

        return powerline_interference

    def generate_composite_noise(
        self,
        time_array: np.ndarray,
        sampling_rate: int,
        noise_levels: Dict[str, float]
    ) -> np.ndarray:
        """
        Generate composite clinical noise combining all artifact sources.

        This method creates a realistic noise signal by combining baseline wander,
        muscle artifact, and powerline interference at specified amplitude levels.
        The resulting composite noise represents the typical contamination found
        in real clinical ECG recordings.

        Args:
            time_array (np.ndarray): Time values at which to generate noise.
            sampling_rate (int): Sampling rate in Hz for proper filtering and
                frequency calculations.
            noise_levels (Dict[str, float]): Dictionary specifying amplitude levels
                for each noise source. Expected keys:
                - 'baseline': Baseline wander amplitude (mV)
                - 'muscle': Muscle artifact amplitude (mV)
                - 'powerline': Powerline interference amplitude (mV)
                Optional key:
                - 'powerline_freq': Powerline frequency (Hz, default 50)

        Returns:
            np.ndarray: Composite noise signal combining all specified sources.

        Raises:
            ValueError: If required noise level keys are missing or invalid.
            RuntimeError: If noise generation fails.

        Example:
            >>> time = np.linspace(0, 10, 5000)
            >>> noise_levels = {
            ...     'baseline': 0.1,      # 0.1 mV baseline wander
            ...     'muscle': 0.02,       # 0.02 mV muscle artifact
            ...     'powerline': 0.01,    # 0.01 mV powerline interference
            ...     'powerline_freq': 60  # 60 Hz (North American)
            ... }
            >>> noise = model.generate_composite_noise(time, 500, noise_levels)
        """
        # Validate inputs
        if len(time_array) == 0:
            raise ValueError("time_array cannot be empty")

        if sampling_rate <= 0:
            raise ValueError(f"Sampling rate must be positive, got {sampling_rate}")

        # Check required noise level keys
        required_keys = ['baseline', 'muscle', 'powerline']
        missing_keys = [key for key in required_keys if key not in noise_levels]
        if missing_keys:
            raise ValueError(f"Missing required noise level keys: {missing_keys}")

        # Validate noise levels are non-negative
        for key, level in noise_levels.items():
            if key in required_keys and level < 0:
                raise ValueError(f"Noise level '{key}' must be non-negative, got {level}")

        try:
            # Initialize composite noise
            composite_noise = np.zeros_like(time_array)

            # Add baseline wander if requested
            if noise_levels['baseline'] > 0:
                baseline_wander = self._generate_baseline_wander(
                    time_array,
                    amplitude=noise_levels['baseline']
                )
                composite_noise += baseline_wander

            # Add muscle artifact if requested
            if noise_levels['muscle'] > 0:
                muscle_artifact = self._generate_muscle_artifact(
                    time_array,
                    amplitude=noise_levels['muscle']
                )
                composite_noise += muscle_artifact

            # Add powerline interference if requested
            if noise_levels['powerline'] > 0:
                # Use custom frequency if specified, otherwise default to 50 Hz
                powerline_freq = noise_levels.get('powerline_freq', 50.0)

                powerline_interference = self._generate_powerline_interference(
                    time_array,
                    sampling_rate,
                    amplitude=noise_levels['powerline'],
                    frequency=powerline_freq
                )
                composite_noise += powerline_interference

            return composite_noise

        except Exception as e:
            raise RuntimeError(f"Clinical noise generation failed: {str(e)}") from e


class RealisticECGGenerator:
    """
    Complete orchestrator for generating realistic clinical ECG data.

    This class combines the biophysical ECG engine with clinical noise models
    to produce synthetic ECG signals that accurately represent real-world
    clinical recording conditions. It provides a high-level API for generating
    challenging, realistic training data for medical AI systems.

    The generator follows the complete workflow:
    1. Generate clean, biophysically accurate ECG using McSharry model
    2. Generate realistic clinical noise (baseline wander, muscle artifact, powerline)
    3. Combine clean signal with noise to create final realistic ECG
    4. Package results with ground truth metadata for supervised learning

    This provides a single, comprehensive interface for the GIF framework to
    generate clinically realistic ECG data that will challenge the DU core
    to develop robust understanding of cardiac signals in noisy environments.

    Key Features:
    - Complete end-to-end realistic ECG generation
    - Configurable heart rate and noise levels
    - Clinical noise sources based on literature
    - Ground truth tracking for supervised learning
    - Structured output with signal components

    Example:
        >>> generator = RealisticECGGenerator(seed=42)
        >>> noise_levels = {'baseline': 0.1, 'muscle': 0.02, 'powerline': 0.01}
        >>> ecg_data = generator.generate(
        ...     duration_seconds=10, sampling_rate=500,
        ...     heart_rate_bpm=75, noise_levels=noise_levels
        ... )
        >>> print(f"Generated realistic ECG with {len(ecg_data)} samples")
    """

    def __init__(self, seed: Optional[int] = None):
        """
        Initialize the realistic ECG generator.

        Args:
            seed (int, optional): Random seed for reproducible data generation.
                If None, uses system entropy for random initialization.
        """
        self.seed = seed
        self.noise_model = ClinicalNoiseModel(seed=seed)

    def generate(
        self,
        duration_seconds: float,
        sampling_rate: int,
        heart_rate_bpm: float,
        noise_levels: Dict[str, float],
        rhythm_class: str = "Normal Sinus Rhythm"
    ) -> pl.DataFrame:
        """
        Generate a complete realistic clinical ECG signal.

        This method executes the full pipeline to create synthetic ECG data
        that combines biophysically accurate cardiac signals with realistic
        clinical noise sources. The result represents the type of challenging
        data encountered in real clinical practice.

        Args:
            duration_seconds (float): Length of ECG recording in seconds.
                Must be positive. Typical values: 5-60 seconds.
            sampling_rate (int): Number of samples per second (Hz).
                Must be positive. Typical clinical values: 250-1000 Hz.
            heart_rate_bpm (float): Target heart rate in beats per minute.
                Must be in physiological range (30-200 BPM).
            noise_levels (Dict[str, float]): Amplitude levels for each noise source.
                Required keys: 'baseline', 'muscle', 'powerline'
                Optional key: 'powerline_freq' (default 50 Hz)
            rhythm_class (str): Ground truth rhythm classification.
                Default "Normal Sinus Rhythm" for healthy cardiac rhythm.

        Returns:
            pl.DataFrame: Complete realistic ECG data with columns:
                - 'time': Time values in seconds
                - 'voltage': Final realistic ECG signal (clean + noise)
                - 'clean_voltage': Original clean biophysical signal
                - 'noise': Composite clinical noise component
                - 'heart_rate_bpm': Ground truth heart rate (constant)
                - 'rhythm_class': Ground truth rhythm classification (constant)
                - Plus individual noise component levels as metadata

        Raises:
            ValueError: If any input parameters are invalid.
            RuntimeError: If ECG generation pipeline fails.

        Example:
            >>> generator = RealisticECGGenerator(seed=123)
            >>> noise_levels = {
            ...     'baseline': 0.08,     # Moderate baseline wander
            ...     'muscle': 0.015,      # Light muscle artifact
            ...     'powerline': 0.005,   # Minimal powerline interference
            ...     'powerline_freq': 60  # North American standard
            ... }
            >>> ecg = generator.generate(
            ...     duration_seconds=15.0, sampling_rate=500,
            ...     heart_rate_bpm=72.0, noise_levels=noise_levels
            ... )
            >>> # Analyze signal quality
            >>> snr = np.std(ecg['clean_voltage']) / np.std(ecg['noise'])
            >>> print(f"Signal-to-noise ratio: {snr:.1f}")
        """
        # Validate inputs
        if duration_seconds <= 0:
            raise ValueError(f"Duration must be positive, got {duration_seconds}")

        if sampling_rate <= 0:
            raise ValueError(f"Sampling rate must be positive, got {sampling_rate}")

        if not (30.0 <= heart_rate_bpm <= 200.0):
            raise ValueError(
                f"Heart rate {heart_rate_bpm} BPM is outside physiological range (30-200 BPM)"
            )

        # Validate noise levels dictionary
        required_noise_keys = ['baseline', 'muscle', 'powerline']
        missing_keys = [key for key in required_noise_keys if key not in noise_levels]
        if missing_keys:
            raise ValueError(f"Missing required noise level keys: {missing_keys}")

        try:
            # 1. Generate clean biophysical ECG signal
            physics_engine = ECGPhysicsEngine(heart_rate_bpm=heart_rate_bpm)
            clean_ecg_df = physics_engine.generate_ecg_segment(
                duration_seconds=duration_seconds,
                sampling_rate=sampling_rate
            )

            # Extract time and voltage arrays
            time_array = clean_ecg_df['time'].to_numpy()
            clean_voltage = clean_ecg_df['voltage'].to_numpy()

            # 2. Generate composite clinical noise
            composite_noise = self.noise_model.generate_composite_noise(
                time_array=time_array,
                sampling_rate=sampling_rate,
                noise_levels=noise_levels
            )

            # 3. Combine clean signal with noise
            final_voltage = clean_voltage + composite_noise

            # 4. Create comprehensive output DataFrame
            n_samples = len(time_array)
            result_df = pl.DataFrame({
                # Primary signal data
                "time": time_array,
                "voltage": final_voltage,
                "clean_voltage": clean_voltage,
                "noise": composite_noise,

                # Ground truth metadata (constant for all samples)
                "heart_rate_bpm": [heart_rate_bpm] * n_samples,
                "rhythm_class": [rhythm_class] * n_samples,

                # Noise level metadata
                "baseline_noise_level": [noise_levels['baseline']] * n_samples,
                "muscle_noise_level": [noise_levels['muscle']] * n_samples,
                "powerline_noise_level": [noise_levels['powerline']] * n_samples,
                "powerline_frequency": [noise_levels.get('powerline_freq', 50.0)] * n_samples,
            })

            return result_df

        except Exception as e:
            if isinstance(e, (ValueError, RuntimeError)):
                raise  # Re-raise our custom exceptions
            else:
                raise RuntimeError(f"Realistic ECG generation failed: {str(e)}") from e


# Example usage and comprehensive validation
if __name__ == "__main__":
    """
    Example usage demonstrating the complete ECG clinical data pipeline.

    This section provides working examples of both clean biophysical ECG
    generation and realistic clinical data with noise, showing the difference
    between perfect signals and clinically realistic recordings.
    """
    print("ECG Clinical Data Generator - Complete Pipeline")
    print("=" * 60)

    # PART 1: Demonstrate Realistic Clinical ECG Generation
    print("\nPART 1: REALISTIC CLINICAL ECG GENERATION")
    print("-" * 45)

    # 1. Create realistic ECG generator
    print("1. Creating realistic ECG generator...")
    realistic_generator = RealisticECGGenerator(seed=42)

    # Define clinical noise levels for different scenarios
    noise_scenarios = {
        "Quiet Clinical Environment": {
            'baseline': 0.05,     # Minimal baseline wander
            'muscle': 0.01,       # Very low muscle artifact
            'powerline': 0.005,   # Minimal powerline interference
            'powerline_freq': 50  # European standard
        },
        "Typical Clinical Environment": {
            'baseline': 0.1,      # Moderate baseline wander
            'muscle': 0.02,       # Light muscle artifact
            'powerline': 0.01,    # Low powerline interference
            'powerline_freq': 60  # North American standard
        },
        "Noisy Clinical Environment": {
            'baseline': 0.15,     # Significant baseline wander
            'muscle': 0.04,       # Moderate muscle artifact
            'powerline': 0.02,    # Noticeable powerline interference
            'powerline_freq': 50  # European standard
        }
    }

    # 2. Generate realistic ECG data for different scenarios
    print("2. Generating realistic ECG data for different clinical scenarios...")

    for scenario_name, noise_levels in noise_scenarios.items():
        print(f"\n   Scenario: {scenario_name}")
        print(f"   Noise levels: {noise_levels}")

        try:
            # Generate realistic ECG
            realistic_ecg = realistic_generator.generate(
                duration_seconds=10.0,
                sampling_rate=500,
                heart_rate_bpm=75.0,
                noise_levels=noise_levels,
                rhythm_class="Normal Sinus Rhythm"
            )

            # Analyze the realistic data
            time_values = realistic_ecg['time'].to_numpy()
            final_voltage = realistic_ecg['voltage'].to_numpy()
            clean_voltage = realistic_ecg['clean_voltage'].to_numpy()
            noise_component = realistic_ecg['noise'].to_numpy()

            # Calculate statistics
            clean_rms = np.std(clean_voltage)
            noise_rms = np.std(noise_component)
            snr = clean_rms / noise_rms if noise_rms > 0 else float('inf')

            print(f"   ✓ Generated {len(realistic_ecg)} samples over 10 seconds")
            print(f"   - Clean signal RMS: {clean_rms:.3f} mV")
            print(f"   - Noise RMS: {noise_rms:.3f} mV")
            print(f"   - Signal-to-noise ratio: {snr:.1f}")
            print(f"   - Voltage range: {final_voltage.min():.3f} to {final_voltage.max():.3f} mV")

            # Validate signal quality
            if snr > 10.0:
                print(f"   ✓ Good signal quality (SNR = {snr:.1f})")
            elif snr > 5.0:
                print(f"   ⚠ Moderate signal quality (SNR = {snr:.1f})")
            else:
                print(f"   ⚠ Poor signal quality (SNR = {snr:.1f})")

            # Optional: Save example data
            try:
                filename = f"realistic_ecg_{scenario_name.lower().replace(' ', '_')}.csv"
                realistic_ecg.write_csv(filename)
                print(f"   ✓ Example data saved to '{filename}'")
            except Exception:
                print(f"   ⚠ Could not save example file")

        except Exception as e:
            print(f"   ✗ Error generating {scenario_name}: {e}")

    # PART 2: Compare Clean vs Realistic ECG
    print(f"\nPART 2: CLEAN VS REALISTIC ECG COMPARISON")
    print("-" * 45)

    # 3. Generate clean ECG for comparison
    print("3. Generating clean biophysical ECG for comparison...")
    try:
        clean_engine = ECGPhysicsEngine(heart_rate_bpm=75.0)
        clean_ecg = clean_engine.generate_ecg_segment(
            duration_seconds=10.0,
            sampling_rate=500
        )

        clean_time = clean_ecg['time'].to_numpy()
        clean_signal = clean_ecg['voltage'].to_numpy()

        print(f"   ✓ Generated clean ECG with {len(clean_ecg)} samples")
        print(f"   - Voltage range: {clean_signal.min():.3f} to {clean_signal.max():.3f} mV")
        print(f"   - Signal RMS: {np.std(clean_signal):.3f} mV")
        print(f"   - Noise level: 0.000 mV (perfect)")

    except Exception as e:
        print(f"   ✗ Error generating clean ECG: {e}")
        clean_signal = None

    # 4. Compare signal characteristics
    if clean_signal is not None:
        print("4. Comparing clean vs realistic ECG characteristics...")

        # Use typical clinical noise levels for comparison
        typical_noise = noise_scenarios["Typical Clinical Environment"]
        realistic_ecg_typical = realistic_generator.generate(
            duration_seconds=10.0,
            sampling_rate=500,
            heart_rate_bpm=75.0,
            noise_levels=typical_noise
        )

        realistic_signal = realistic_ecg_typical['voltage'].to_numpy()
        noise_only = realistic_ecg_typical['noise'].to_numpy()

        # Calculate comparison metrics
        clean_peak_to_peak = clean_signal.max() - clean_signal.min()
        realistic_peak_to_peak = realistic_signal.max() - realistic_signal.min()
        noise_rms = np.std(noise_only)

        print(f"   Clean ECG:")
        print(f"   - Peak-to-peak amplitude: {clean_peak_to_peak:.3f} mV")
        print(f"   - RMS amplitude: {np.std(clean_signal):.3f} mV")
        print(f"   - Noise level: 0.000 mV")

        print(f"   Realistic ECG (typical clinical):")
        print(f"   - Peak-to-peak amplitude: {realistic_peak_to_peak:.3f} mV")
        print(f"   - RMS amplitude: {np.std(realistic_signal):.3f} mV")
        print(f"   - Noise RMS: {noise_rms:.3f} mV")

        # Calculate signal degradation
        amplitude_change = abs(realistic_peak_to_peak - clean_peak_to_peak) / clean_peak_to_peak
        snr_db = 20 * np.log10(np.std(clean_signal) / noise_rms) if noise_rms > 0 else float('inf')

        print(f"   Signal quality metrics:")
        print(f"   - Amplitude change: {amplitude_change*100:.1f}%")
        print(f"   - Signal-to-noise ratio: {snr_db:.1f} dB")

        if snr_db > 20:
            print(f"   ✓ Excellent signal quality (SNR > 20 dB)")
        elif snr_db > 15:
            print(f"   ✓ Good signal quality (SNR > 15 dB)")
        elif snr_db > 10:
            print(f"   ⚠ Acceptable signal quality (SNR > 10 dB)")
        else:
            print(f"   ⚠ Poor signal quality (SNR ≤ 10 dB)")

    # 5. Test individual noise components
    print("\n5. Testing individual noise components...")

    noise_model = ClinicalNoiseModel(seed=123)
    test_time = np.linspace(0, 5, 2500)  # 5 seconds at 500 Hz

    # Test baseline wander
    try:
        baseline = noise_model._generate_baseline_wander(test_time, amplitude=0.1)
        baseline_freq = 0.2  # Expected ~0.2 Hz
        print(f"   ✓ Baseline wander: RMS = {np.std(baseline):.4f} mV")
    except Exception as e:
        print(f"   ✗ Baseline wander error: {e}")

    # Test muscle artifact
    try:
        muscle = noise_model._generate_muscle_artifact(test_time, amplitude=0.02)
        print(f"   ✓ Muscle artifact: RMS = {np.std(muscle):.4f} mV")
    except Exception as e:
        print(f"   ✗ Muscle artifact error: {e}")

    # Test powerline interference
    try:
        powerline = noise_model._generate_powerline_interference(test_time, 500, amplitude=0.01)
        print(f"   ✓ Powerline interference: RMS = {np.std(powerline):.4f} mV")
    except Exception as e:
        print(f"   ✗ Powerline interference error: {e}")

    # 6. Final validation
    print("\n6. Final validation...")

    try:
        # Test edge cases
        print("   Testing parameter validation...")

        # Test invalid heart rate
        try:
            RealisticECGGenerator().generate(5.0, 500, 300.0, typical_noise)
            print("   ⚠ Should have rejected invalid heart rate")
        except ValueError:
            print("   ✓ Correctly rejected invalid heart rate (300 BPM)")

        # Test missing noise levels
        try:
            incomplete_noise = {'baseline': 0.1}  # Missing muscle and powerline
            RealisticECGGenerator().generate(5.0, 500, 75.0, incomplete_noise)
            print("   ⚠ Should have rejected incomplete noise levels")
        except ValueError:
            print("   ✓ Correctly rejected incomplete noise levels")

        print("   ✓ Parameter validation working correctly")

    except Exception as e:
        print(f"   ✗ Validation error: {e}")

    print(f"\n" + "=" * 60)
    print("ECG CLINICAL DATA GENERATOR VALIDATION COMPLETE!")
    print("Ready for integration with GIF framework encoder interfaces.")
    print("Complete pipeline: Clean biophysics + Clinical noise = Realistic ECG")
    print("=" * 60)
